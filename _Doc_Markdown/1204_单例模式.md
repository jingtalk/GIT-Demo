[TOC]

# 单例模式

简述单例模式 与 线程安全，在各种情况下出现的问题。



## 1. 饿汉式

> 线程安全

```java
public class MySingleton {
	// 私有静态变量
	private static MySingleton sInst = new MySingleton();
	// 私有构造函数
	private MySingleton(){}
	// 公有静态getInstance方法
	public static MySingleton getInstance() {
		return sInst;
	}
}
```

## 2. 懒汉式

> 非线程安全

```java
public class MySingleton {
	
	private static MySingleton sInst = null;
	
	private MySingleton(){}
	
	public static MySingleton getInstance() {
		if (sInst == null) {	// A
			sInst = new MySingleton();
		}
		return sInst;
	}
}
```

`如果Thread 1 与 Thread 2 都通过了条件判断 A，有可能创建不同的实例。`

## 3. 懒汉式 + synchronized 

> 线程安全 + 效率低下

```java
public class MySingleton {
	
	private static MySingleton sInst = null;
	
	private MySingleton(){}
	
	public synchronized static MySingleton getInstance() {
		if (sInst == null) {	// A
			sInst = new MySingleton();
		}
		return sInst;
	}
}
```

`原则上只有创建实例的时候才需要加锁，但上面这种写法在获取单例的时候也需要一次同步锁的开销，所以执行效率低。`

## 4. 懒汉式 + 同步代码块 + All

> 线程安全 + 效率低下

```java
public class MySingleton {
	
	private static MySingleton sInst = null;
	
	private MySingleton(){}
	
	public static MySingleton getInstance() {
      	synchronized (MySingleton.class) {
			if(sInst != null) { // 懒汉式 
				
			} else {
				// 创建实例之前可能会有一些准备性的耗时工作 
				sInst = new MySingleton();
			}
		}
		return sInst;
	}
}
```

`使用同步代码块将全部的实现代码都锁上了，效率同样低下。`

## 5. 懒汉式 + 同步代码块 + Part

> 非线程安全

```java
public class MySingleton {
	
	private static MySingleton sInst = null;
	
	private MySingleton(){}
	
	public static MySingleton getInstance() {
      	if(sInst != null) { // 懒汉式 
				
		} else {
			// 创建实例之前可能会有一些准备性的耗时工作 
          	synchronized (MySingleton.class) {
				sInst = new MySingleton();
            }
		}      	
		return sInst;
	}
}
```

`解决了效率低下的问题，但是非线程安全。`

## 6. 懒汉式 + DCL

> 非线程安全

```java
private static MySingleton sInst = null;  
public static MySingleton getInstance() {  
    if (sInst == null) {                      // 1
        synchronized (MySingleton.class) {    // 2
            if (sInst == null) {              // 3
                sInst = new MySingleton(); 	  // 4
            }
        }
    }
    return sInst;                             // 5
}

```

简单分析一下代码的运行：

1. 线程 1 运行到 1 处，第一次进入，这里肯定是为 `true` 的；
2. 线程 1 运行到 2 处，获得锁 `MySingleton.class`；
3. 线程 1 运行到 3 处，这时 sInst 还是 null，所以继续往下运行，创建一个新的实例；
4. 线程 1 运行到 6 处，修改 sInst 的值。这一步非常关键，这里的解析是，因为这些修改可能因为和其他赋值操作运行被重新排序（Re-order），这就可能导致先修改了 sInst的值，而 `new MySingleton()` 这个构造函数并没有执行完。而在这个时候，程序切换到线程 2；
5. 线程 2 运行到 1 处，因为第 4 步的时候，线程 1 已经给 sInst 赋值了，所以 `sInst== null` 的判断为 `false`，线程 2 就直接返回 sInst了，但是这个时候 sInst并没有被初始化完成，直接使用它可能会导致程序崩溃。

为什么会出现 Re-Order？赋值了，但没有初始化又是怎么回事？这是由于 Java 的内存模型决定的。问题主要出现在第4行，这里的构造函数可能会被编译成内联的（inline），在 Java 虚拟机中运行的时候编译成执行指令以后，可以用如下的伪代码来表示：

```java
temp = allocat()； // 分配内存  
sInst = temp;  
constructor(temp); // 真正执行构造函数 
```

构造函数可能会被分为两块：先分配内存并赋值，再初始化。

解决方案见下第7节。

## 7. 懒汉式 + DCL + volatile 

> 线程安全

在 Java 5 之后，引入扩展关键字 `volatile` 的功能，它能保证：

>1. 对 `volatile` 变量的写操作，不允许和它之前的读写操作打乱顺序。
>2. 对 `volatile` 变量的读操作，不允许和它之后的读写乱序。

```java
private static volatile MySingleton sInst = null;  
public static MySingleton getInstance() {  
    if (sInst == null) {                     
        synchronized (MySingleton.class) {      
            if (sInst == null) {              
                sInst = new MySingleton(); 	
            }
        }
    }
    return sInst;                               
}
```

上面的代码中，只需要对 sInst 加上关键字 `volatile` 修饰即可。

**对 volatile 变量的读写操作是一个比较重的操作，还可以优化。**

## 8. 懒汉式 + DCL + volatile + 优化版

> 线程安全 + 性能提升

```java
private static volatile MySingleton sInst = null;  
public static MySingleton getInstance() {  
  	MySingleton instance = sInst;	// 此处创建临时变量
    if (instance == null) {                     
        synchronized (MySingleton.class) {
          	instance = sInst;
            if (instance == null) {              
                instance = new MySingleton();
              	sInst = instance;
            }
        }
    }
    return instance;        // 返回临时变量                       
}
```

通过这样修改以后，在运行过程中，除了第一次以外，其他的调用只要访问 volatile 变量 sInst 一次，这样能提高 25% 的性能（[Wikipedia](3)）。

## 9. 静态内置类

> 线程安全

```java
public class MySingleton {  
      
    //内部类  
    private static class MySingletonHolder {  
        private static MySingleton instance = new MySingleton();  
    }   
      
    private MySingleton(){}  
       
    public static MySingleton getInstance() {   
        return MySingletonHolder.instance;  
    }  
} 
```

这种实现，它能够延迟初始化（lazy initialization），并且多线程安全，还能保证高性能。

这里是利用了 Java 的语言特性，内部类只有在使用的时候，才回去加载，从而初始化内部静态变量。关于线程安全，这是 Java 运行环境自动给你保证的，在加载的时候，会自动隐形的同步。在访问对象的时候，不需要同步 Java 虚拟机又会自动给你取消同步，所以效率非常高。

## 10. 静态内置类 + 优化 



## 11. Static 代码块

## 12. 枚举

## 13. 枚举 + 优化

# Reference

1. [Java 单例真的写对了么][1]
2. [高并发下线程安全的单例模式（最全最经典）][2]


[1]:https://www.race604.com/java-double-checked-singleton/
[2]:http://blog.csdn.net/cselmu9/article/details/51366946
[3]:https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java



